package quickchatapplication;

import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Pattern;
import javax.swing.JOptionPane;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

/**
 * messages class - holds a single message entity (id, recipient, text, hash, status, sender)
 * and provides messaging UI utilities used by QuickChatApplication.
 *
 * Changes:
 * - Message ID must be exactly 10 digits (numeric).
 * - Message hash autogenerated with format:
 *      <first-two-digits-of-messageID>:<message-number>:<FIRSTWORD+LASTWORD-UPPERCASE>
 *   e.g. 08:3:HITHANKS
 * - Added resetMessageCount() for stable test data.
 * - Removed unused SHA-256 code and other duplicates.
 */
public class messages {

    // Enable test mode to prevent file I/O and GUI popups during unit tests / CI
    public static boolean TEST_MODE = false;

    // Instance fields used by TaskReport and elsewhere
    private String id;
    private String recipient;
    private String text;
    private String hash;
    private String status;   // "Sent", "Stored", "Disregard"
    private String sender;   // e.g. "Developer" or other

    // Small shared bookkeeping for the interactive messaging UI
    private static int messageCount = 0; // Tracks total messages sent via startMessaging()
    private static ArrayList<String> sentMessagesSummaries = new ArrayList<>();

    // ---------- Getters / Setters ----------
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getRecipient() { return recipient; }
    public void setRecipient(String recipient) { this.recipient = recipient; }

    public String getText() { return text; }
    public void setText(String text) { this.text = text; }

    public String getHash() { return hash; }
    public void setHash(String hash) { this.hash = hash; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getSender() { return sender; }
    public void setSender(String sender) { this.sender = sender; }

    // ---------- Validation & Utilities ----------
    // Check that Message ID is exactly 10 digits (numbers only)
    public boolean checkMessageID(String messageID) {
        if (messageID == null) return false;
        return Pattern.matches("^\\d{10}$", messageID);
    }

    // Ensure recipient cell number starts with +27 and followed by 9 digits (South Africa)
    public boolean checkRecipientCell(String recipientCell) {
        if (recipientCell == null) return false;
        String regex = "^\\+27\\d{9}$";
        return Pattern.matches(regex, recipientCell);
    }

    // Reset message counter (useful for deterministic test setup)
    public static void resetMessageCount() {
        messageCount = 0;
    }

    // Increment messageCount and return new count
    public static int incrementMessageCount() {
        messageCount++;
        return messageCount;
    }

    // Create a message hash per your spec:
    // first-two-digits-of-messageID : messageNum : FIRSTWORD + LASTWORD (uppercased, punctuation removed)
    public String createMessageHash(String messageID, int messageNum, String messageText) {
        String idPrefix = "00";
        if (messageID != null && messageID.length() >= 2) {
            idPrefix = messageID.substring(0, 2);
        } else if (messageID != null) {
            // pad if shorter (shouldn't happen if IDs are validated)
            idPrefix = String.format("%-2s", messageID).replace(' ', '0');
        }

        String firstWord = "";
        String lastWord = "";
        if (messageText != null && !messageText.trim().isEmpty()) {
            String[] tokens = messageText.trim().split("\\s+");
            firstWord = tokens[0].replaceAll("[^A-Za-z0-9]", "");
            lastWord = tokens[tokens.length - 1].replaceAll("[^A-Za-z0-9]", "");
            if (firstWord == null) firstWord = "";
            if (lastWord == null) lastWord = "";
        }

        String combined = (firstWord + lastWord).toUpperCase();
        // If combined is empty use an explicit placeholder to avoid empty hash tail
        if (combined.isEmpty()) combined = "NOMSG";

        return idPrefix + ":" + messageNum + ":" + combined;
    }

    // Allow user to choose action for message (UI)
    public String sentMessage() {
        if (TEST_MODE) {
            // In tests we won't show dialogs â€” return Send by default
            return "Send";
        }
        Object[] options = {"Send Message", "Disregard Message", "Store Message to send later"};
        int choice = JOptionPane.showOptionDialog(null,
                "Choose what to do with this message:",
                "Send Message Options",
                JOptionPane.DEFAULT_OPTION,
                JOptionPane.INFORMATION_MESSAGE,
                null, options, options[0]);

        if (choice == 0) return "Send";
        else if (choice == 1) return "Disregard";
        else if (choice == 2) return "Store";
        else return "Invalid";
    }

    // Print sent message summaries (UI-friendly)
    public String printMessages() {
        if (sentMessagesSummaries.isEmpty()) {
            return "No messages have been sent yet.";
        }
        StringBuilder sb = new StringBuilder("Recently Sent Messages:\n");
        for (String msg : sentMessagesSummaries) {
            sb.append(msg).append("\n---------------------------\n");
        }
        return sb.toString();
    }

    // Return total number of sent messages (from startMessaging)
    public int returnTotalMessages() {
        return messageCount;
    }

    // Add a sent message summary for UI listing
    public static void addSentSummary(String summary) {
        sentMessagesSummaries.add(summary);
    }

    // Helper: generate a random 10-digit numeric ID as a string with leading zeros allowed
    public static String generate10DigitID() {
        long value = ThreadLocalRandom.current().nextLong(0L, 1_000_000_0000L); // 0 .. 9999999999
        return String.format("%010d", value);
    }

    // Store message to JSON file (appends a single-line array). Skips writing when TEST_MODE==true.
    @SuppressWarnings("unchecked")
    public void storeMessageToFile(String messageID, String recipient, String messageText, String hash) {
        JSONObject msgObject = new JSONObject();
        msgObject.put("MessageID", messageID);
        msgObject.put("Recipient", recipient);
        msgObject.put("Message", messageText);
        msgObject.put("MessageHash", hash);
        msgObject.put("Status", "Stored");
        msgObject.put("Sender", "Developer");

        JSONArray msgArray = new JSONArray();
        msgArray.add(msgObject);

        if (TEST_MODE) {
            // Do not write during tests
            return;
        }

        try (FileWriter file = new FileWriter("stored_messages.json", true)) {
            // append a single-line JSON array for easy reading by TaskReport
            file.write(msgArray.toJSONString());
            file.write(System.lineSeparator());
            JOptionPane.showMessageDialog(null, "Message stored for later sending.");
        } catch (IOException e) {
            JOptionPane.showMessageDialog(null, "Error storing message: " + e.getMessage());
        }
    }

    // --------- Interactive Messaging Flow (used by QuickChatApplication) ----------
    // This method uses JOptionPane; when TEST_MODE==true it returns immediately (no GUI)
    public void startMessaging() {
        if (TEST_MODE) {
            // Avoid GUI interactions in test mode
            return;
        }

        JOptionPane.showMessageDialog(null, "Welcome to QuickChat.");

        boolean running = true;

        while (running) {
            String menu = JOptionPane.showInputDialog("""
                    Choose an option:
                    1) Send Messages
                    2) Show Recently Sent Messages
                    3) Quit
                    """);

            if (menu == null) {
                // treat cancel as quit
                running = false;
                continue;
            }

            switch (menu) {
                case "1" -> {
                    int totalToSend;
                    try {
                        String input = JOptionPane.showInputDialog("How many messages do you want to send?");
                        if (input == null) break;
                        totalToSend = Integer.parseInt(input);
                    } catch (NumberFormatException e) {
                        JOptionPane.showMessageDialog(null, "Invalid number. Returning to menu.");
                        continue;
                    }

                    for (int i = 0; i < totalToSend; i++) {
                        // Generate Message ID (exactly 10 digits)
                        String messageID = generate10DigitID();
                        while (!checkMessageID(messageID)) {
                            messageID = generate10DigitID();
                        }

                        // Recipient number input
                        String recipient;
                        do {
                            recipient = JOptionPane.showInputDialog("Enter recipient cell (must start with +27):");
                            if (recipient == null) break;
                            if (!checkRecipientCell(recipient)) {
                                JOptionPane.showMessageDialog(null, "Invalid cell number format. Try again.");
                            }
                        } while (recipient != null && !checkRecipientCell(recipient));
                        if (recipient == null) break;

                        // Message input
                        String messageText;
                        do {
                            messageText = JOptionPane.showInputDialog("Enter your message (max 250 characters):");
                            if (messageText == null) break;
                            if (messageText.length() > 250) {
                                JOptionPane.showMessageDialog(null, "Please enter a message of less than 250 characters.");
                            }
                        } while (messageText != null && messageText.length() > 250);
                        if (messageText == null) break;

                        int currentCount = incrementMessageCount();
                        String hash = createMessageHash(messageID, currentCount, messageText);

                        // Show hash to user
                        JOptionPane.showMessageDialog(null, "Message Hash: " + hash);

                        String decision = sentMessage();

                        if ("Send".equals(decision)) {
                            addSentSummary("Message ID: " + messageID + "\nHash: " + hash + "\nRecipient: " + recipient + "\nMessage: " + messageText);
                            JOptionPane.showMessageDialog(null, "Message Sent!\n\n" +
                                    "Message ID: " + messageID + "\nMessage Hash: " + hash +
                                    "\nRecipient: " + recipient + "\nMessage: " + messageText);

                            // Add to TaskReport's sentMessages for persistence/reporting
                            messages m = new messages();
                            m.setId(messageID);
                            m.setHash(hash);
                            m.setRecipient(recipient);
                            m.setText(messageText);
                            m.setSender("Developer");
                            m.setStatus("Sent");
                            TaskReport.sentMessages.add(m);
                            TaskReport.messageHashes.add(hash);
                            TaskReport.messageIDs.add(messageID);
                            TaskReport.saveSentMessages();

                        } else if ("Store".equals(decision)) {
                            // Save stored message to file and in-memory list
                            storeMessageToFile(messageID, recipient, messageText, hash);

                            messages m = new messages();
                            m.setId(messageID);
                            m.setHash(hash);
                            m.setRecipient(recipient);
                            m.setText(messageText);
                            m.setSender("Developer");
                            m.setStatus("Stored");
                            TaskReport.storedMessages.add(m);
                            TaskReport.messageHashes.add(hash);
                            TaskReport.messageIDs.add(messageID);
                            TaskReport.saveStoredMessages();

                            JOptionPane.showMessageDialog(null, "Message stored for later sending.");
                        } else if ("Disregard".equals(decision)) {
                            JOptionPane.showMessageDialog(null, "Message disregarded.");

                            messages m = new messages();
                            m.setId(messageID);
                            m.setHash(hash);
                            m.setRecipient(recipient);
                            m.setText(messageText);
                            m.setSender("Developer");
                            m.setStatus("Disregard");
                            TaskReport.disregardedMessages.add(m);
                            TaskReport.messageHashes.add(hash);
                            TaskReport.messageIDs.add(messageID);
                            TaskReport.saveDisregardedMessages();
                        }
                    }

                    JOptionPane.showMessageDialog(null, "Total messages sent: " + returnTotalMessages());
                }

                case "2" -> {
                    // Show recently sent messages via TaskReport menu
                    TaskReport.runReportMenu();
                }

                case "3" -> {
                    running = false;
                    JOptionPane.showMessageDialog(null, "Exiting QuickChat. Goodbye!");
                }

                default -> JOptionPane.showMessageDialog(null, "Invalid option. Please try again.");
            }
        }
    }
}
  